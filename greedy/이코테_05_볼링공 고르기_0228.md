# 이코테_05_볼링공 고르기_0228: 난이도 1 (23.02.28 풀이)

### 풀이 방법
1. 낮은 무게부터 정렬
2. 중복해서 세지 않으려면, 결국 자기 공 무게보다 더 무거운 공과 짝지어짐.
3. 동일 무게의 공도 서로 다른 공으로 인식하기 때문에, 해당 무게의 공의 개수만큼 곱하면 됨
4. 따라서, 현재 무게의 공의 개수 * 더 무거운 공의 개수(남은 공의 개수)를 더해가면 됨.

### 코드
```python
n, m = map(int, input().split())
ball = sorted(list(map(int, input().split())))

cnt_all = 0
answer = 0

for weight in range(m):
    cnt = ball.count(weight) # 현재 무게의 공의 개수
    cnt_all += cnt # 더 무거운 공의 순서.

    # 현재 무게의 공의 개수 * 더 무거운 공의 개수(남은 공의 개수)
    answer += cnt * len(ball[cnt_all:])
    
print(answer)
```

### 예시 풀이
#### 입력
```
5 3
1 3 2 3 2
```

#### 출력
```
8
```

#### 풀이
1. 정렬
```
1 2 2 3 3
```
2. 현재 무게의 공의 개수 * 더 무거운 공의 개수(남은 공의 개수)를 더해가기.
```
현재 공 1: 1개 * 더 무거운 공(2, 3): 4개 = 4
현재 공 2: 2개 * 더 무거운 공(3): 2개 = 4
현재 공 3: 2개 * 더 무거운 공 없음.

4 + 4 = 8
```
